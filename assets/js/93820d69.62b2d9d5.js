"use strict";(globalThis.webpackChunkmahout_website=globalThis.webpackChunkmahout_website||[]).push([[4782],{2088(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"api/python/qumat","title":"Qumat","description":"qumat.QuMat(backend_config)","source":"@site/docs/api/python/qumat.md","sourceDirName":"api/python","slug":"/api/python/qumat","permalink":"/docs/api/python/qumat","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/mahout/tree/main/docs/docs/api/python/qumat.md","tags":[],"version":"current","frontMatter":{"title":"Qumat"},"sidebar":"docsSidebar","previous":{"title":"index","permalink":"/docs/api/python/"},"next":{"title":"Qumat.Qdp","permalink":"/docs/api/python/qumat.qdp"}}');var s=i(4848),r=i(8453);const a={title:"Qumat"},l="qumat",c={},d=[{value:"qumat.QuMat(backend_config)",id:"qumatqumatbackend_config",level:3},{value:"apply_cnot_gate",id:"apply_cnot_gate",level:4},{value:"apply_cswap_gate",id:"apply_cswap_gate",level:4},{value:"apply_hadamard_gate",id:"apply_hadamard_gate",level:4},{value:"apply_not_gate",id:"apply_not_gate",level:4},{value:"apply_pauli_x_gate",id:"apply_pauli_x_gate",level:4},{value:"apply_pauli_y_gate",id:"apply_pauli_y_gate",level:4},{value:"apply_pauli_z_gate",id:"apply_pauli_z_gate",level:4},{value:"apply_rx_gate",id:"apply_rx_gate",level:4},{value:"apply_ry_gate",id:"apply_ry_gate",level:4},{value:"apply_rz_gate",id:"apply_rz_gate",level:4},{value:"apply_swap_gate",id:"apply_swap_gate",level:4},{value:"apply_t_gate",id:"apply_t_gate",level:4},{value:"apply_toffoli_gate",id:"apply_toffoli_gate",level:4},{value:"apply_u_gate",id:"apply_u_gate",level:4},{value:"bind_parameters",id:"bind_parameters",level:4},{value:"calculate_prob_zero",id:"calculate_prob_zero",level:4},{value:"create_empty_circuit",id:"create_empty_circuit",level:4},{value:"draw",id:"draw",level:4},{value:"draw_circuit",id:"draw_circuit",level:4},{value:"execute_circuit",id:"execute_circuit",level:4},{value:"get_final_state_vector",id:"get_final_state_vector",level:4},{value:"measure_overlap",id:"measure_overlap",level:4},{value:"swap_test",id:"swap_test",level:4}];function h(e){const n={code:"code",em:"em",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"qumat",children:"qumat"})}),"\n",(0,s.jsx)(n.h3,{id:"qumatqumatbackend_config",children:"qumat.QuMat(backend_config)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class QuMat(backend_config):\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Bases: ",(0,s.jsx)(n.code,{children:"object"})]}),"\n",(0,s.jsx)(n.p,{children:"Unified interface for quantum circuit operations across multiple backends."}),"\n",(0,s.jsx)(n.p,{children:"Provides a consistent API for creating and manipulating quantum circuits\nusing different quantum computing backends (Qiskit, Cirq, Amazon Braket).\nAbstracts backend-specific details for gate operations, circuit execution,\nand state measurement."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"backend_config"})," (",(0,s.jsx)(n.em,{children:"dict"}),") \u2013 Configuration dictionary for the quantum backend.\nMust contain ",(0,s.jsx)(n.code,{children:"backend_name"})," (str) and ",(0,s.jsx)(n.code,{children:"backend_options"})," (dict).\nThe ",(0,s.jsx)(n.code,{children:"backend_options"})," should include ",(0,s.jsx)(n.code,{children:"simulator_type"})," and ",(0,s.jsx)(n.code,{children:"shots"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_cnot_gate",children:"apply_cnot_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_cnot_gate(control_qubit_index, target_qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Controlled-NOT (CNOT) gate between two qubits."}),"\n",(0,s.jsx)(n.p,{children:"Fundamental for entangling qubits. Flips the target qubit if and only\nif the control qubit is in the |1\u27e9 state."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"control_qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the control qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"target_qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_cswap_gate",children:"apply_cswap_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_cswap_gate(control_qubit_index, target_qubit_index1, target_qubit_index2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a controlled-SWAP (Fredkin) gate."}),"\n",(0,s.jsx)(n.p,{children:"Swaps the states of two target qubits if and only if the control\nqubit is in the |1\u27e9 state."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"control_qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the control qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"target_qubit_index1"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the first target qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"target_qubit_index2"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the second target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_hadamard_gate",children:"apply_hadamard_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_hadamard_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Hadamard gate to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Creates a superposition state, transforming |0\u27e9 to (|0\u27e9 + |1\u27e9)/\u221a2\nand |1\u27e9 to (|0\u27e9 - |1\u27e9)/\u221a2."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_not_gate",children:"apply_not_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_not_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a NOT gate (Pauli-X gate) to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Flips the qubit state from |0\u27e9 to |1\u27e9 or |1\u27e9 to |0\u27e9.\nEquivalent to the Pauli-X gate."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_pauli_x_gate",children:"apply_pauli_x_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_pauli_x_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Pauli-X gate to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Equivalent to the NOT gate. Flips the qubit state from |0\u27e9 to |1\u27e9\nor |1\u27e9 to |0\u27e9."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_pauli_y_gate",children:"apply_pauli_y_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_pauli_y_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Pauli-Y gate to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Rotates the qubit around the Y-axis of the Bloch sphere, affecting\nboth phase and amplitude."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_pauli_z_gate",children:"apply_pauli_z_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_pauli_z_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Pauli-Z gate to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Rotates the qubit around the Z-axis of the Bloch sphere, altering\nthe phase without changing the amplitude."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_rx_gate",children:"apply_rx_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_rx_gate(qubit_index, angle)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a rotation around the X-axis to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Rotates the qubit by the given angle around the X-axis of the Bloch\nsphere. The angle can be a static value or a parameter name for\nparameterized circuits."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"angle"})," (",(0,s.jsx)(n.em,{children:"float"})," ",(0,s.jsx)(n.em,{children:"|"})," ",(0,s.jsx)(n.em,{children:"str"}),") \u2013 Rotation angle in radians. Can be a float or a string\nparameter name."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_ry_gate",children:"apply_ry_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_ry_gate(qubit_index, angle)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a rotation around the Y-axis to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Rotates the qubit by the given angle around the Y-axis of the Bloch\nsphere. The angle can be a static value or a parameter name for\nparameterized circuits."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"angle"})," (",(0,s.jsx)(n.em,{children:"float"})," ",(0,s.jsx)(n.em,{children:"|"})," ",(0,s.jsx)(n.em,{children:"str"}),") \u2013 Rotation angle in radians. Can be a float or a string\nparameter name."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_rz_gate",children:"apply_rz_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_rz_gate(qubit_index, angle)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a rotation around the Z-axis to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Rotates the qubit by the given angle around the Z-axis of the Bloch\nsphere. The angle can be a static value or a parameter name for\nparameterized circuits."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"angle"})," (",(0,s.jsx)(n.em,{children:"float"})," ",(0,s.jsx)(n.em,{children:"|"})," ",(0,s.jsx)(n.em,{children:"str"}),") \u2013 Rotation angle in radians. Can be a float or a string\nparameter name."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_swap_gate",children:"apply_swap_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_swap_gate(qubit_index1, qubit_index2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Swap the states of two qubits."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index1"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the first qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index2"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the second qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_t_gate",children:"apply_t_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_t_gate(qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a T-gate (\u03c0/8 gate) to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"Applies a relative pi/4 phase (multiplies the |1> state by e^{i*pi/4}).\nEssential for universal quantum computation when combined with\nHadamard and CNOT gates."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_toffoli_gate",children:"apply_toffoli_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_toffoli_gate(control_qubit_index1, control_qubit_index2, target_qubit_index)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a Toffoli gate (CCX gate) to three qubits."}),"\n",(0,s.jsx)(n.p,{children:"Acts as a quantum AND gate. Flips the target qubit if and only if\nboth control qubits are in the |1\u27e9 state."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"control_qubit_index1"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the first control qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"control_qubit_index2"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the second control qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"target_qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the target qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"apply_u_gate",children:"apply_u_gate"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"apply_u_gate(qubit_index, theta, phi, lambd)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Apply a U gate (universal single-qubit gate) to the specified qubit."}),"\n",(0,s.jsx)(n.p,{children:"A universal single-qubit gate parameterized by three angles (theta,\nphi, lambd) that can represent any single-qubit unitary operation."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit_index"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the qubit."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"theta"})," (",(0,s.jsx)(n.em,{children:"float"}),") \u2013 First rotation angle in radians."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"phi"})," (",(0,s.jsx)(n.em,{children:"float"}),") \u2013 Second rotation angle in radians."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"lambd"})," (",(0,s.jsx)(n.em,{children:"float"}),") \u2013 Third rotation angle in radians."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"bind_parameters",children:"bind_parameters"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"bind_parameters(parameter_values)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Bind numerical values to circuit parameters."}),"\n",(0,s.jsx)(n.p,{children:"Assigns numerical values to symbolic parameters defined in parameterized\ngates."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"parameter_values"})," (",(0,s.jsx)(n.em,{children:"dict"}),") \u2013 Dictionary mapping parameter names to numerical\nvalues."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"ValueError"})," \u2013 If a parameter name is not found in the circuit\u2019s\nparameter list."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"calculate_prob_zero",children:"calculate_prob_zero"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"calculate_prob_zero(results, ancilla_qubit)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Calculate the probability of measuring the ancilla qubit in |0\u27e9 state."}),"\n",(0,s.jsx)(n.p,{children:"Delegates to the backend-specific implementation. Different backends\nmay use different qubit ordering conventions (little-endian vs big-endian)."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"results"})," (",(0,s.jsx)(n.em,{children:"dict"})," ",(0,s.jsx)(n.em,{children:"|"})," ",(0,s.jsx)(n.em,{children:"list"})," *[*",(0,s.jsx)(n.em,{children:"dict"})," ",(0,s.jsx)(n.em,{children:"]"}),") \u2013 Measurement results from ",(0,s.jsx)(n.code,{children:"execute_circuit()"}),". Format\ndepends on the backend."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ancilla_qubit"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the ancilla qubit."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nProbability of measuring the ancilla qubit in |0\u27e9 state."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\nfloat"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"create_empty_circuit",children:"create_empty_circuit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"create_empty_circuit(num_qubits=None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Create an empty quantum circuit with the specified number of qubits."}),"\n",(0,s.jsx)(n.p,{children:"Must be called before applying any gates or executing operations."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"num_qubits"})," (",(0,s.jsx)(n.em,{children:"int"})," ",(0,s.jsx)(n.em,{children:"|"})," ",(0,s.jsx)(n.em,{children:"None"})," ",(0,s.jsx)(n.em,{children:","})," ",(0,s.jsx)(n.em,{children:"optional"}),") \u2013 Number of qubits in the circuit. If ",(0,s.jsx)(n.code,{children:"None"}),",\ncreates a circuit without pre-allocated qubits."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"draw",children:"draw"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"draw()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Alias for draw_circuit() for convenience."}),"\n",(0,s.jsx)(n.p,{children:"Provides a shorter method name that matches common quantum computing\nlibrary conventions and documentation examples."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nCircuit visualization. The exact type depends on the backend."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\nstr | object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"draw_circuit",children:"draw_circuit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"draw_circuit()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Visualize the quantum circuit."}),"\n",(0,s.jsx)(n.p,{children:"Generates a visual representation of the circuit. The output format\ndepends on the backend implementation."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nCircuit visualization. The exact type depends on the backend."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\nstr | object"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"execute_circuit",children:"execute_circuit"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"execute_circuit(parameter_values=None)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Execute the quantum circuit and return the measurement results."}),"\n",(0,s.jsx)(n.p,{children:"Runs the circuit on the configured backend. For parameterized circuits,\nprovide parameter values to bind before execution."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsx)(n.strong,{children:"parameter_values"})," (",(0,s.jsx)(n.em,{children:"dict"})," ",(0,s.jsx)(n.em,{children:","})," ",(0,s.jsx)(n.em,{children:"optional"}),") \u2013 Dictionary mapping parameter names to numerical\nvalues. Binds these values to circuit parameters before execution."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nMeasurement results. Format depends on the backend:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Qiskit/Braket: Dictionary with state strings as keys and counts as values"}),"\n",(0,s.jsx)(n.li,{children:"Cirq: List of dictionaries with integer states as keys"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\ndict | list[dict]"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"get_final_state_vector",children:"get_final_state_vector"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"get_final_state_vector()\n"})}),"\n",(0,s.jsx)(n.p,{children:"Return the final state vector of the quantum circuit."}),"\n",(0,s.jsx)(n.p,{children:"The complete quantum state vector after circuit execution,\nrepresenting the full quantum state of all qubits. For parameterized\ncircuits, call bind_parameters() first to set parameter values."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nThe final state vector as a numpy array."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\nnumpy.ndarray"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ValueError"})," \u2013 If parameterized circuit has unbound parameters."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"measure_overlap",children:"measure_overlap"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"measure_overlap(qubit1, qubit2, ancilla_qubit=0)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Measure the overlap (fidelity) between two quantum states using the swap test."}),"\n",(0,s.jsxs)(n.p,{children:["Creates a swap test circuit to calculate the similarity between the\nquantum states on ",(0,s.jsx)(n.code,{children:"qubit1"})," and ",(0,s.jsx)(n.code,{children:"qubit2"}),". Returns the squared overlap\n|\u27e8\u03c8|\u03c6\u27e9|\xb2, which represents the fidelity between the two states."]}),"\n",(0,s.jsx)(n.p,{children:"The swap test measures P(ancilla=0), related to overlap as:\nP(0) = (1 + |\u27e8\u03c8|\u03c6\u27e9|\xb2) / 2"}),"\n",(0,s.jsx)(n.p,{children:"For certain states (especially identical excited states), global phase\neffects may cause the ancilla to measure predominantly |1\u27e9 instead of |0\u27e9.\nThis method handles both cases by taking the measurement probability\ncloser to 1."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit1"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the first qubit containing state |\u03c8\u27e9."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit2"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the second qubit containing state |\u03c6\u27e9."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ancilla_qubit"})," (",(0,s.jsx)(n.em,{children:"int"})," ",(0,s.jsx)(n.em,{children:","})," ",(0,s.jsx)(n.em,{children:"optional"}),") \u2013 Index of the ancilla qubit. Default is 0. Should be\ninitialized to |0\u27e9."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Returns:"}),"\nThe squared overlap |\u27e8\u03c8|\u03c6\u27e9|\xb2 between the two states (fidelity),\nclamped to the range [0.0, 1.0]."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Return type:"}),"\nfloat"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"swap_test",children:"swap_test"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"swap_test(ancilla_qubit, qubit1, qubit2)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Implement the swap test circuit for measuring overlap between two quantum states."}),"\n",(0,s.jsxs)(n.p,{children:["Measures the inner product between the states on ",(0,s.jsx)(n.code,{children:"qubit1"})," and ",(0,s.jsx)(n.code,{children:"qubit2"}),".\nThe probability of measuring the ancilla qubit in state |0\u27e9 is related\nto the overlap as: P(0) = (1 + |\u27e8\u03c8|\u03c6\u27e9|\xb2) / 2"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameters:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ancilla_qubit"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the ancilla qubit (should be initialized to |0\u27e9)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit1"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the first qubit containing state |\u03c8\u27e9."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"qubit2"})," (",(0,s.jsx)(n.em,{children:"int"}),") \u2013 Index of the second qubit containing state |\u03c6\u27e9."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Raises:"}),"\n",(0,s.jsx)(n.strong,{children:"RuntimeError"})," \u2013 If the circuit has not been initialized."]}),"\n"]})]})}function o(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>a,x:()=>l});var t=i(6540);const s={},r=t.createContext(s);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);